\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{float}

\usepackage{listings}
\usepackage{xcolor}

\usepackage{tikz}
\usepackage{float}

\theoremstyle{definition}
\newtheorem{rules}{Rule}[subsection]
\newtheorem{definition}[rules]{Definition}
\newtheorem{remark}[rules]{Remark}
\newtheorem{example}[rules]{Example}

\theoremstyle{plain}
\newtheorem{theorem}[rules]{Theorem}

\definecolor{bluekeywords}{rgb}{0.13, 0.19, 0.7}
\definecolor{goldenkeywords}{rgb}{0.67, 0.58, 0.13}
\definecolor{greencomments}{rgb}{0.1, 0.5, 0.2}
\definecolor{redstrings}{rgb}{0.8, 0.15, 0.1}
\definecolor{graynumbers}{rgb}{0.5, 0.5, 0.5}
\definecolor{subtlegray}{rgb}{0.98, 0.98, 0.98}

\usepackage{lstautogobble}
\usepackage{listings}

\lstset{
    autogobble,    
    columns=fullflexible,
    showspaces=false,
    showtabs=false,
    breaklines=true,
    showstringspaces=false,
    numbers=left,
    breakatwhitespace=true,
    escapeinside={(*@}{@*)},
    rulecolor=\color{lightgray},
    backgroundcolor=\color{subtlegray},
    commentstyle=\color{greencomments},
    keywordstyle=\color{bluekeywords},
    ndkeywordstyle=\color{goldenkeywords},
    stringstyle=\color{redstrings},
    numberstyle=\color{graynumbers},
    basicstyle=\ttfamily\linespread{1.15}\footnotesize,
    frame=tb,
    framesep=12pt,
    framexleftmargin=12pt,
    tabsize=4,
    captionpos=b
}

\lstdefinelanguage{TML}{ 
    keywords={changeto, move, goto, if, switch, while, module, accept, reject, halt, alphabet},
    ndkeywords={left, right, tapehead, blank},
    sensitive=true,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]',
    morestring=[b]"
}

\title{TML Documentation}
\author{Pete Gautam}

\begin{document}
    % \begin{abstract}
    %     This document contains the specification of the TM programming language (called Turing Machine Language, or TML), and how it can be used to change the state of a tape. In the first section, we discuss TML rules (the EBNF and contextual rules), and give examples of valid and invalid TML programs. In the second section, we define tapes and how a TML program can be executed on a tape. This section also includes some examples of executing a TM program on a given tape.
    % \end{abstract}

    \maketitle

    \section{Specification}
    \subsection{TML rules}
    In this section, we define the rules that a valid program in TML should obey. First, the following is the specification of the TML in EBNF:
    \begin{align*}
        \textit{program} &= \textit{alphabet} \ \textit{module}^+ \\
        \textit{alphabet} &= \texttt{alphabet} \ \texttt{=} \ \texttt{\{} \ \textit{seq-val} \ \texttt{\}} \\
        \textit{module} &= \texttt{module} \ \textit{id} \ \texttt{\{} \ \textit{block}^+ \ \texttt{\}} \\
        \textit{block} &= \textit{basic-block} \ | \ \textit{switch-block} \\
        \textit{switch-block} &= \texttt{switch tapehead \{} \ \textit{case-block}^+ \ \texttt{\}} \\
        \textit{case-block} &= \textit{if-block} \ | \ \textit{while-block} \\
        \textit{if-block} &= \texttt{if} \ \textit{seq-val} \ \texttt{\{} \textit{block}^+ \texttt{\}} \\
        \textit{while-block} &= \texttt{while} \ \textit{seq-val} \ \texttt{\{} \ \textit{core-com}^+ \ \texttt{\}} \\
        \textit{basic-block} &= (\textit{core-com} \ | \ \textit{flow-com})^+ \\
        \textit{core-com} &= \texttt{move} \ \textit{direction} \ | \ \texttt{changeto} \ \textit{value} \\
        \textit{flow-com} &= \texttt{goto} \ \textit{id} \ | \ \textit{terminate} \\
        \textit{terminate} &= \texttt{reject} \ | \ \texttt{accept} \\
        \textit{direction} &= \texttt{left} \ | \ \texttt{right} \\
        \textit{seq-val} &= (\textit{value} \texttt{,})^* \ \textit{value} \\
        \textit{value} &= \texttt{blank} \ | \ \texttt{a} \ | \ \texttt{b} \ | \ \texttt{c} \ | \ \dots \ | \ \texttt{z} \ | \ \texttt{0} \ | \ \texttt{1} \ | \ \dots \ | \ \texttt{9} \\
        \textit{id} &= (\texttt{a} \ | \ \texttt{b} \ | \ \texttt{c} \ | \ \dots \ | \ \texttt{z} \ | \ \texttt{A} \ | \ \texttt{B} \ | \ \texttt{C} \ | \ \dots \ | \ \texttt{Z})^+
    \end{align*}
    
    Next, we analyse the rules of a TML program.
    \begin{rules}
        A valid TML program is composed of the \emph{alphabet}, followed by one or more \emph{modules}.
    \end{rules}
    \begin{rules}
        A module contains a collection of a \emph{blocks} (a specific sequence of commands). There are two types of blocks- \emph{basic blocks} and \emph{switch blocks}.
    \end{rules}
    \begin{rules}
        A basic block consists of \emph{basic commands} (\textit{changeto}, \textit{move} or \textit{flow} command). A basic block consists of at least one basic command, but it is not necessary for a basic block to be composed of all the basic commands. If multiple commands are present in a basic block, they must be in the following order- \textit{changeto}, \textit{move} and \textit{flow} command.
    \end{rules}
    \begin{example}
        The following is a simple TML program:
\begin{lstlisting}[language=TML]
alphabet = {"a", "b"}
module simple {
    changeto blank
    move right
    changeto a
    move left
    accept
}
\end{lstlisting}
    It is composed of a single module, called \texttt{simple}. The module has 2 basic blocks- lines 3-4, and lines 5-7.
    \end{example}
    \begin{remark}
        In the example above, we could have also said that there were 5 basic blocks, one in each line from line 3 to line 7. If it is possible for us to break a module into blocks in different ways, we always choose the one that ends up with the fewest number of blocks. In this case, we cannot have just one block since lines 3-5 do not form a basic block- there are two \textit{changeto} commands. So, we have 2 basic blocks.
    \end{remark}
    
    \begin{rules}
        A \emph{switch block} consists of a single switch statement. A switch statement must contain precisely one case (\textit{if} or \textit{while} command) for each of the letter in the alphabet, including the \texttt{blank} letter. The first block of a case block must be a basic block.
    \end{rules}
    \begin{rules}
        The body of an \textit{if} command can be composed of multiple blocks. These blocks can be both basic blocks and switch blocks.
    \end{rules}
    \begin{rules}
        The body of a \textit{while} command must be composed of a single basic block. The basic block cannot have a \textit{flow} command. Further, a switch block must be the final block present; it cannot be followed by any other block, basic or switch.
    \end{rules}
    
    \begin{example}
        The following is another TML program:
\begin{lstlisting}[language=TML]
alphabet = {"0", "1"}
module isEven {
    switch tapehead {
        while 0, 1 {
            move right
        } if blank {
            move left
            switch tapehead {
                if 0 {
                    accept
                } if 1, blank {
                    reject
                }
            }
        }
    }
}
\end{lstlisting}
    It is composed of a single module \texttt{isEven}. The module has:
    \begin{itemize}
        \item a switch block at lines 3-16;
        \item a basic block at line 5;
        \item a basic block at line 7;
        \item a nested switch block at lines 8-14;
        \item a basic block at line 10; and
        \item a basic block at line 12.
    \end{itemize}
    \end{example}
\begin{example}
    Consider the following TML program:
\begin{lstlisting}[language=TML]
alphabet = {"0", "1"}
module isEven {
    switch tapehead {
        while 0, 1 {
            move right
            accept
        } if blank {
            move left
            switch tapehead {
                if 0 {
                    accept
                } if 1, blank {
                    reject
                }
            }
        }
    }
}
\end{lstlisting}
    This program is not valid because it contains a terminating command in the \textit{while} block at lines 4-6. This does not logically make sense- if we want to terminate, it should be an \textit{if} block; there is no way a \textit{while} block can continue after rejecting the program in the first iteration.
    \end{example}

    \subsection{TML execution}
    In this section, we discuss how a valid TML program can execute a tape. The tape we will be using has infinite spaces in both directions.
    \begin{definition}
        Let $\Sigma$ be an alphabet. A \emph{tape $T$ on $\Sigma$} is a function $T: \mathbb{Z} \to \Sigma^+$, where $\Sigma^+ = \Sigma \cup \{\texttt{blank}\}$, where \texttt{blank} is a symbol not present in $\Sigma$.
    \end{definition}
    % TODO: Reference
    \begin{remark}
        A valid TML program always specifies the alphabet. This corresponds to the alphabet $\Sigma$ used in the tape.
    \end{remark}
    \noindent Although there are many possible tapes, we will only be interested in tapes that obey some rules.
    \begin{definition}
        Let $\Sigma$ be an alphabet and let $T$ be a tape on $\Sigma$. Then, $T$ is a \emph{valid tape} if only finitely many symbols on $T$ are not \texttt{blank}, and all the values that can be non-\texttt{blank} are non-\texttt{blank}. That is, there exist integers $a, b$ such that for all $x \in \mathbb{Z}$, $T(x)$ is not \texttt{blank} if and only $x \geq a$ and $x \leq b$.
    \end{definition}
    \begin{remark}
        In a valid tape, there are only finitely many values that are non-\texttt{blank} and there is no gap between any two non-\texttt{blank} values.
    \end{remark}
    \begin{remark}
        We require the tape to have finitely many non-\texttt{blank} entries so that we start execution with the tapehead at the first non-\texttt{blank} entry. Moreover, this ensures that going from the start of the tape to the end does not create an infinite loop- this is a very common procedure. If we allowed for infinitely many non-\texttt{blank} entries, we would need to specify where the initial location of the tapehead is. Moreover, there would be much fewer programs that we could write which are guaranteed to terminate.
    \end{remark}
    \begin{remark}
        A valid tape can always be represented as an illustration. For instance, consider the following valid tape $T$ on $\{0, 1\}$:
        \[T(x) = \begin{cases}
            0 & x \in \{1, 3, 4\} \\
            1 & x \in \{2\} \\
            \texttt{blank} & \text{otherwise}.
        \end{cases}\]
        Then, an illustration of the tape is:
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \draw[thick] (-0.25, 0) -- (0, 0);
                \foreach \x[count=\i] in {0, 1, 0, 0} {
                    \draw[thick] (\i*0.5-0.25, 0) -- (\i*0.5, 0);
                    \node at (\i*0.5-0.125, 0.3) {\texttt{\x}};
                }
                \draw[thick] (2.25, 0) -- (2.5, 0);
            \end{tikzpicture}
            \caption{The tape as a diagram.}
        \end{figure}
        \noindent Only the non-\texttt{blank} values are represented. Blank ones are represented by empty lines.
    \end{remark}
    \begin{remark}
        More than one tape definition can result in the same figure. In the case above, the following tape $S$ on $\{0, 1\}$ also corresponds to the same figure.
        \[S(x) = \begin{cases}
            0 & x \in \{0, 2, 3\} \\
            1 & x \in \{1\} \\
            \texttt{blank} & \text{otherwise}.
        \end{cases}\]        
    \end{remark}
    \begin{example}
Consider the following TML program:
\begin{lstlisting}[language=TML]
alphabet = {"a", "b"}
module isSecondValueA {
    move right
    switch tapehead {
        if a {
            accept
        } if b, blank {
            reject
        }
    }
}
\end{lstlisting}
    The following is a valid tape for the program:
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \draw[thick] (-0.25, 0) -- (0, 0);
            \foreach \x[count=\i] in {a, b, b, a} {
                \draw[thick] (\i*0.5-0.25, 0) -- (\i*0.5, 0);
                \node at (\i*0.5-0.125, 0.3) {\texttt{\x}};
            }
            \draw[thick] (0.5*5-0.25, 0) -- (0.5*5, 0);
        \end{tikzpicture}
    \end{figure}
    \end{example}

    Now, we will define how we can execute a TML program on a valid tape.
    \begin{definition}
        Let $P$ be a TML program, let $T$ be a valid tape for the program with $i$ the smallest integer such that $T(i)$ is not \texttt{blank} ($i$ is the initial \emph{tapehead index} and $T(i)$ the initial \textit{tapehead value}). We \emph{execute $P$ on $T$} by constructing (countable) different tapes until execution is terminated. We first take the given tape and the tapehead index and execute it using the first block $b$ in the first module of $P$ to construct the next tape $T'$ and next tapehead index $i'$. This is done as follows:
        \begin{itemize}
            \item if the block is a switch block, we take the first block from the case corresponding to the tapehead value- now, we must have a basic block;
            \item if there is a \textit{changeto} \texttt{val} command in the basic block, the next tape $T'$ is given by 
            \[T'(x) = \begin{cases}
                \texttt{val} & x = i \\
                T(x) & \text{otherwise}.
            \end{cases}\]
            If the \textit{changeto} command is missing, then the tapehead $T' = T$.
            \item if there is a \textit{move} \texttt{dir} command in the basic block, the next tapehead index is given by:
            \[i' = \begin{cases}
                i+1 & \texttt{dir} = \texttt{right} \\
                i-1 & \texttt{dir} = \texttt{left}.
            \end{cases}\]
            If the \textit{move} command is missing, then $i' = i-1$.
            \item we either terminate or determine the next block $b'$ to execute (in decreasing precedence):
            \begin{itemize}
                \item if the block is the body of a while case block, then $b' = b$, i.e. we execute this switch block again (not necessarily the same case block); 
                \item if the block contains a terminating \textit{flow} command, we terminate and return the terminated state (\texttt{accept} or \texttt{reject});
                \item if the block contains a \textit{goto} \texttt{mod} command, then $b'$ is the first block of the module \texttt{mod};
                \item if the block is not the final block in the current module, then $b'$ is next block in this module;
                \item otherwise, we terminate and return the state \texttt{reject}.
            \end{itemize}
        \end{itemize}
        If execution is not terminated, we execute the block $b'$ with the new tape $T'$ and a new tapehead index $i'$, and continue until we terminate (which not happen).
    \end{definition}
    \begin{remark}
        By construction, for a valid program, precisely one of the 5 possible step applies when choosing the next block to execute or terminate.
    \end{remark}
    
    \begin{example}
        Consider the following TML program:
\begin{lstlisting}[language=TML]
alphabet = {"a", "b"}
module palindrome {
    switch tapehead {
        if blank {
            accept
        } if a {
            changeto blank
            move right
            switch tapehead {
                while a, b {
                    move right
                } if blank {
                    move left
                    switch tapehead {
                        if blank, a {
                            changeto blank
                            move left
                            goto restart
                        } if b {
                            reject
                        }
                    }
                }
            }
        }  if b {
            changeto blank
            move right
            switch tapehead {
                while a, b {
                    move right
                } if blank {
                    move left
                    switch tapehead {
                        if blank, b {
                            changeto blank
                            move left
                            goto restart
                        } if a {
                            reject
                        }
                    }
                }
            }
        }
    }
}
module restart {
    switch tapehead {
        while a, b {
            move left
        } if blank {
            move right
            goto palindrome
        }
    }
}
\end{lstlisting}
    We will execute the program on the following tape.
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \draw[thick] (-0.25, 0) -- (0, 0);
            \foreach \x[count=\i] in {a, b, a} {
                \draw[thick] (\i*0.5-0.25, 0) -- (\i*0.5, 0);
                \node at (\i*0.5-0.125, 0.3) {\texttt{\x}};
            }
            \draw[thick] (1.75, 0) -- (2, 0);
    
            \draw[->, thick] (0.375, -0.5) -- (0.375, -0.1);
        \end{tikzpicture}
    \end{figure}
    \noindent The arrow points to the tapehead value. We first execute the switch block at \texttt{palindrome}. Since the tapehead value is \texttt{a}, we execute the basic block at lines 7-8. So, we change the tapehead value to \texttt{blank}, and the tapehead moves to the right by one step. Since this is an \textit{if}-block, without a flow command, and there is a block following this one, the next block to be executed is the switch block at lines 9-24. Now, the current tape is the following.
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \draw[thick] (-0.25, 0) -- (0, 0);
            \foreach \x[count=\i] in {b, a} {
                \draw[thick] (\i*0.5-0.25, 0) -- (\i*0.5, 0);
                \node at (\i*0.5-0.125, 0.3) {\texttt{\x}};
            }
            \draw[thick] (1.25, 0) -- (1.5, 0);
    
            \draw[->, thick] (0.375, -0.5) -- (0.375, -0.1);
        \end{tikzpicture}
    \end{figure}
    \noindent The current block is a switch block. The tapehead value is \texttt{b}, so we are at the \textit{while} command at line 11. The basic block here only contains a \textit{move} command. So, we leave the tape as is, and the tapehead moves to the right once. This is a \textit{while} command, so the next block to execute is still this switch block. The current tape state is the following.
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \draw[thick] (-0.25, 0) -- (0, 0);
            \foreach \x[count=\i] in {b, a} {
                \draw[thick] (\i*0.5-0.25, 0) -- (\i*0.5, 0);
                \node at (\i*0.5-0.125, 0.3) {\texttt{\x}};
            }
            \draw[thick] (1.25, 0) -- (1.5, 0);
    
            \draw[->, thick] (0.875, -0.5) -- (0.875, -0.1);
        \end{tikzpicture}
    \end{figure}
    \noindent The current block is still a switch block. The tapehead value is \texttt{a}, so we execute the same \textit{while} command at line 11. Moreover, the next block to execute is still the switch block. Now, the current tape state is the following.
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \draw[thick] (-0.25, 0) -- (0, 0);
            \foreach \x[count=\i] in {b, a} {
                \draw[thick] (\i*0.5-0.25, 0) -- (\i*0.5, 0);
                \node at (\i*0.5-0.125, 0.3) {\texttt{\x}};
            }
            \draw[thick] (1.25, 0) -- (1.5, 0);
    
            \draw[->, thick] (1.375, -0.5) -- (1.375, -0.1);
        \end{tikzpicture}
    \end{figure}
    \noindent For the third time, we are executing the same switch block. Now, however, the tapehead value is \texttt{blank}, so we execute the first block of the \textit{if} command at line 13. Since this is an \textit{if} command and this is not the last block in the if command, the next block to execute is the switch block at lines 14-22.
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \draw[thick] (-0.25, 0) -- (0, 0);
            \foreach \x[count=\i] in {b, a} {
                \draw[thick] (\i*0.5-0.25, 0) -- (\i*0.5, 0);
                \node at (\i*0.5-0.125, 0.3) {\texttt{\x}};
            }
            \draw[thick] (1.25, 0) -- (1.5, 0);
    
            \draw[->, thick] (0.875, -0.5) -- (0.875, -0.1);
        \end{tikzpicture}
    \end{figure}
    \noindent Now, the current block is a switch block. The tapehead value is \texttt{a}, so we take the basic block at lines 16-18. The value of the tapehead becomes \texttt{blank}, and the tapehead moves to the left. The next block to execute is the switch block in \texttt{restart}.
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \draw[thick] (-0.25, 0) -- (0, 0);
            \foreach \x[count=\i] in {b} {
                \draw[thick] (\i*0.5-0.25, 0) -- (\i*0.5, 0);
                \node at (\i*0.5-0.125, 0.3) {\texttt{\x}};
            }
            \draw[thick] (0.75, 0) -- (1, 0);
    
            \draw[->, thick] (0.375, -0.5) -- (0.375, -0.1);
        \end{tikzpicture}
    \end{figure}
    \noindent Since the current tapehead value is \texttt{b}, we execute the basic block at line 50. So, we move to the left, and the tape is left as is. Moreover, since this is a while block, the next block to execute is still the switch block.
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \draw[thick] (-0.25, 0) -- (0, 0);
            \foreach \x[count=\i] in {b} {
                \draw[thick] (\i*0.5-0.25, 0) -- (\i*0.5, 0);
                \node at (\i*0.5-0.125, 0.3) {\texttt{\x}};
            }
            \draw[thick] (0.75, 0) -- (1, 0);
    
            \draw[->, thick] (-0.125, -0.5) -- (-0.125, -0.1);
        \end{tikzpicture}
    \end{figure}
    \noindent Since the current tapehead state is \texttt{blank}, we execute the basic block at lines 52-53. So, we move to the right, and the tape is left as is. The next block to execute is the switch block at \texttt{palindrome}.
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \draw[thick] (-0.25, 0) -- (0, 0);
            \foreach \x[count=\i] in {b} {
                \draw[thick] (\i*0.5-0.25, 0) -- (\i*0.5, 0);
                \node at (\i*0.5-0.125, 0.3) {\texttt{\x}};
            }
            \draw[thick] (0.75, 0) -- (1, 0);
    
            \draw[->, thick] (0.375, -0.5) -- (0.375, -0.1);
        \end{tikzpicture}
    \end{figure}
    \noindent Since the current tapehead state is \texttt{b}, we execute the basic block at lines 26-27. So, we change the tapehead value to \texttt{blank}, move to the right. This is a while block, so the next block to be executed is still the switch block.
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \draw[thick] (-0.25, 0) -- (0, 0);
            \draw[thick] (0.25, 0) -- (0.5, 0);
            \draw[thick] (0.75, 0) -- (1, 0);
    
            \draw[->, thick] (0.875, -0.5) -- (0.875, -0.1);
        \end{tikzpicture}
    \end{figure}
    \noindent At this point, the tapehead index moves between the blank values as we move to the basic block at line 5. At this point, we accept the tape.
\end{example}
\newpage

\section{Proof of Equivalence}
\subsection{Complete TML programs}
\noindent Complete programs in the TML are a specific type of TML programs that are very detailed and obey different properties. As such, it is very easy to construct the TM corresponding to a complete program. In this section, we will build to the definition complete programs from complete blocks and modules.
\begin{definition}
    Let $P$ be a valid TML program, and let $B$ be a basic block in $P$. We say that $B$ is a \emph{complete block} if it is composed of all the 3 commands: a \textit{changeto} command, a \textit{move} command, and a \textit{flow} command. If the \textit{flow} command is missing, we say that $B$ is a \emph{partially complete block}.
\end{definition}

Complete blocks contain all the information required to transition from one state to another. This is because of the following:
\begin{itemize}
    \item A complete block lists the next value of the tapehead; we assume the original value of the tapehead to be known outwith the block.
    \item A complete block states which direction the tapehead is moving- left or right.
    \item A complete block determines precisely what the next state is for the block- it is either a terminating state or we are going to the initial block of another module.
\end{itemize}        
We can convert any basic block with a \textit{flow} command to a complete block by adding the default commands (i.e. moving left and changing the tapehead value to the current value). Equally, it is quite straightforward to convert a complete block into a subpart of a Turing Machine.
\begin{example}
    Consider the following complete block.
\begin{lstlisting}[language=TML]
changeto a
move right
goto s2
\end{lstlisting}
    \noindent If we are at the state $s_1$, and the block applies when the tapehead value is $b$, then the following is the corresponding subpart of the Turing Machine:
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s1) at (0, 0) {$s_1$};
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s2) at (2.5, 0) {$s_2$};

            \draw[->] (s1) -- node[above] {$b \to a, R$} (s2);
        \end{tikzpicture}
        \caption{The TM subpart of the given Turing Machine complete block.}
    \end{figure}            
\end{example}

Using complete and partially complete blocks, we can define complete modules.
\begin{definition}
    Let $P$ be a valid TML program, and let $M$ be a module in $P$. We say that $M$ is a \emph{complete module} if all of the following hold:
    \begin{itemize}
        \item it is composed of a single switch block;
        \item the body of each \textit{if} command is a complete block; and
        \item the body of each \textit{while} command is a partially complete block.
    \end{itemize}
\end{definition}

\begin{remark}
    For a \textit{while} command, the body must be partially complete because the corresponding edge in the TM is always a loop.
\end{remark}

It is quite easy to map a single module to a sub-Turing machine. It precisely corresponds to having an initial state and edges going to other states as dictated by each case. Because the program is valid, we know that there is a case for each letter in the alphabet, including the \texttt{blank} letter.
\begin{example}
    Consider the following complete module.
\begin{lstlisting}[language=TML]
module basic {
    switch tapehead {
        while b {
            changeto b
            move right
        } if a, blank {
            changeto blank
            move left
            reject
        }
    }
}
\end{lstlisting}
If the alphabet is composed only of $a$ and $b$, then the corresponding sub-TM is the following:
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=20pt] (s1) at (0, 0) {$s_1$};
        \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=20pt] (sR) at (3, 0) {$s_R$};

        \draw[->] (s1) -- node[above] {$a | \# \to \#, L$} (sR);
        \draw[->] (s1) edge[loop above] node[above] {$b \to b, R$} (s1);
    \end{tikzpicture}
    \caption{The sub-TM of the given Turing Machine complete module.}
\end{figure}
\end{example}

\begin{remark}
    In the example above, we consider the state $s_1$ to be the \emph{corresponding state} of the module. For every complete module, there is precisely one corresponding state.
\end{remark}

Now, we can define complete programs.
\begin{definition}
    Let $P$ be a TML program. We say that $P$ is \emph{complete} if it is composed of one or more complete modules. We also require every \textit{goto} command in a complete block to refer to an existing module.
\end{definition}

\begin{remark}
    The second condition (called \emph{valid reference}) is required for any TML program.
\end{remark}

\begin{remark}
    In general, a complete program is not composed of a single complete module. We will see later that a relatively simple module can be broken down into a couple of complete modules, each of which refer to each other.
\end{remark}

Every module in the program can be converted to a state, along with directed edges to other states. If the program is complete, then we ensure that the states connect to form a valid TM.

\begin{example}
    Consider the following complete program.
\begin{lstlisting}[language=TML]
alphabet = {"a", "b"}
module isDivTwo {
    switch tapehead {
        while 0 {
            changeto 0
            move right
        } while 1 {
            changeto 1
            move right
        } if blank {
            changeto blank
            move left
            goto isDivTwoCheck
        }
    }
}
module isDivTwoCheck {
    switch tapehead {
        if 0 {
            changeto 0
            move left
            accept
        } if 1, blank {
            changeto blank
            move left
            reject
        }
    }
}
\end{lstlisting}
Then, the corresponding TM is the following:
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s0) at (0, 0) {$s_0$};
        \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s1) at (2.5, 0) {$s_1$};
        \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (sY) at (4.5, 1) {$s_Y$};
        \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (sN) at (4.5, -1) {$s_N$};
        
        \draw[->] (-1, 0) -- (s0);
        \draw[->] (s0) edge[loop above] node[above] {$0 \to 0, R$} (s0);
        \draw[->] (s0) edge[loop below] node[below] {$1 \to 1, R$} (s0);
        \draw[->] (s0) -- node[above] {$\# \to \#, L$} (s1);
        \draw[->] (s1) -- node[above, rotate=26] {$0 \to 0, L$} (sY);
        \draw[->] (s1) -- node[above, rotate=-26] {$1 \to 1, L$} node[below, rotate=-26] {$\# \to \#, L$} (sN);
    \end{tikzpicture}
    \caption{The TM of the given TML program. The state $s_0$ corresponds to the module \texttt{isDivTwo} and the state $s_1$ corresponds to the module \texttt{isDivTwoCheck}.}
\end{figure}
\end{example}

\begin{remark}
    In the example above, we converted a complete TML program into a TM. It is equally possible to convert a TM into a complete TML program.
\end{remark}

\begin{example}
    Consider the following TM:
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s0) at (0, 0) {$s_0$};
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s1) at (2, 2) {$s_1$};
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s2) at (2, -2) {$s_2$};
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s3) at (4.5, 2) {$s_3$};
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s4) at (4.5, -2) {$s_4$};
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (sY) at (2.5, 0) {$s_Y$};
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (sN) at (5, 0) {$s_N$};
            
            \draw[->] (-1, 0) -- (s0);
            \draw[->] (s0) -- node[above, rotate=45] {$a \to a, R$} (s1);
            \draw[->] (s0) -- node[below, rotate=-45] {$b \to b, R$} (s2);
            \draw[->] (s0) -- node[above] {$\# \to \#, R$} (sY);
            \draw[->] (s1) edge[loop above] node[above, text width=2cm, align=center] {$a \to a, R$ $b \to b, R$} (s1);
            \draw[->] (s2) edge[loop below] node[below, text width=2cm, align=center] {$a \to a, R$ $b \to b, R$} (s2);
            \draw[->] (s1) -- node[above] {$\# \to \#, L$} (s3);
            \draw[->] (s2) -- node[below] {$\# \to \#, L$} (s4);
            \draw[->] (s3) -- node[above, rotate=-75, text width=2cm, align=center] {$b \to b, L$ $\# \to \#, L$} (sN);
            \draw[->] (s4) -- node[below, rotate=75, text width=2cm, align=center] {$a \to a, L$ $\# \to \#, L$} (sN);
            \draw[->] (s3) -- node[below, rotate=48] {$a \to a, L$} (sY);
            \draw[->] (s4) -- node[above, rotate=-48] {$b \to b, L$} (sY);
        \end{tikzpicture}
        \caption{A Turing machine}
    \end{figure}
    \noindent Then, its corresponding TML program is:
\begin{lstlisting}[language=TML]
alphabet = {"a", "b"}
module startsAndEndsSame {
    switch tapehead {
        if blank {
            accept
        } if a {
            changeto a
            move right
            goto startsAndEndsSameMoveA
        } if b {
            changeto b
            move right
            goto startsAndEndsSameMoveB
        }
    }
}
module startsAndEndsSameMoveA {
    switch tapehead {
        while a {
            changeto a
            move right
        } while b {
            changeto b
            move right
        } if blank {
            changeto blank
            move left
            goto startsAndEndsSameCheckA
        }
    }
}
module startsAndEndsSameCheckA {
    switch tapehead {
        if a {
            changeto a
            move left
            accept
        } if b {
            changeto b
            move left
            reject
        } if blank {
            changeto blank
            move left
            reject
        }
    }
}
module startsAndEndsSameMoveB {
    switch tapehead {
        while a {
            changeto a
            move right
        } while b {
            changeto b
            move right
        } if blank {
            changeto blank
            move left
            goto startsAndEndsSameCheckB
        }
    }
}
module startsAndEndsSameCheckB {
    switch tapehead {
        if a {
            changeto a
            move left
            reject
        } if b {
            changeto b
            move left
            accept
        } if blank {
            changeto blank
            move left
            reject
        }
    }
}
\end{lstlisting}
This is a complete program since TMs always include the required commands corresponding to \textit{if} and \textit{while} commands.
\end{example}

\begin{remark}
    Although a TML program need not be complete, any valid TML program is equivalent to a complete one. So, a TML program that is not be complete is just a compact representation of its complete version.
\end{remark}

\subsection{Complete TML programs to TM}
In this section, we will convert TML programs into TM. To do this, we first need to define TMs.
\begin{definition}
    A \emph{Turing Machine} is a collection $(Q, \Sigma, \delta, q_0)$, where:
    \begin{itemize}
        \item $Q$ is a set of states, including the \texttt{accept} state $q_Y$ and \texttt{reject} state $q_N$;
        \item $\Sigma$ is the set of letters, excluding the \texttt{blank} symbol;
        \item $\delta: Q \setminus \{\texttt{accept}, \texttt{reject}\} \times \Sigma^+ \to Q \times \Sigma^+ \times \{\texttt{left}, \texttt{right}\}$, where $\Sigma^+ = \Sigma \cup \{\texttt{blank}\}$, is the transition function; and
        \item $q_0 \in Q$ is the starting state.
    \end{itemize}
\end{definition}

% TODO: Add reference

\begin{remark}
    The definition of a valid tape only depends on the alphabet. So, for a TM program with language set equal to $\Sigma$ and a TM with alphabet $\Sigma$, the set of valid tapeheads is equivalent.
\end{remark}

Like with TML programs, we can execute a TM on a valid tape.
\begin{definition}
    Let $M$ be a TM, and let $T$ be a valid tape for the program, with $i$ the smallest integer such that $T(i)$ is not \texttt{blank}. We \emph{execute $M$ on $T$} by constructing (countable) different tapes until execution is terminated. We first take the given tape $T$ and the tapehead index $i$, and execute it using the initial state $q_0$. This is done by computing $\delta(q_0, t) = (q_1, t', \texttt{dir})$. Then, 
    \begin{itemize}
        \item the next tape $T'$ is given by
        \[T'(x) = \begin{cases}
            t' & x = i \\
            T(x) & \text{otherwise};
        \end{cases}\]
        \item the next state is $q_1$; and    
        \item the next tapehead index is given by:
        \[i' = \begin{cases}
            i+1 & \texttt{dir} = \texttt{right} \\
            i-1 & \texttt{dir} = \texttt{left}.
        \end{cases}\]
        If the next state $q_1$ is not a terminating state (\texttt{accept} or \texttt{reject}), then we execute the tape $T'$ with the next state $q_1$ and the next tapehead index $i'$.
    \end{itemize}
\end{definition}

% TODO: Some intro
\begin{definition}
    Let $M$ be a TM. For each state $q$ in $M$, we define the \emph{corresponding module for $q$}, $m$, as follows:
        \begin{itemize}
            \item the module contains a single \textit{switch} command;
            \item for each letter $\sigma$ in the alphabet $\Sigma^+$, we find $\delta(q, \sigma) = (q', \sigma', \texttt{dir})$. Then, we add a case in the \textit{switch} command corresponding to letter $\sigma$ (an \textit{if} case if $q' \neq q$, otherwise a \textit{while} case) with:
            \begin{itemize}
                \item \texttt{changeto} $\sigma'$
                \item \texttt{move} \textit{dir}
                \item in the case of an \textit{if} block, if $q'$ is \texttt{accept}, then the command \texttt{accept}; if $q'$ is \texttt{reject}, then the command \texttt{reject}; otherwise, \texttt{goto} $q'$.
            \end{itemize}
        \end{itemize}
        Let $P$ be the program with 
        \begin{itemize}
            \item alphabet $\Sigma$;
            \item modules corresponding to every state $q$;
            \item the module corresponding to the initial state $q_0$ placed at the top.
        \end{itemize}
        We say that $P$ is \emph{the corresponding program for $M$}.
\end{definition}

\begin{remark}
    For any TM $M$, its corresponding program $P$ will be complete. By definition, every module in $P$ is complete.
\end{remark}

\begin{example}
    Consider the following TM:
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s0) at (0, 0) {$s_0$};
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s1) at (2.5, 0) {$s_1$};
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s2) at (5, 0) {$s_2$};
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (sN) at (2.5, -2) {$s_N$};                
            \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (sY) at (5, -2) {$s_Y$};

            \draw[->] (-1, 0) -- (s0);
            \draw[->] (s0) -- node[above] {$a \to \#, R$} (s1);
            \draw[->] (s1) -- node[above] {$\# \to \#, L$} (s2);
            
            \draw[->] (s1) edge[loop above] node[above, text width=2cm, align=center] {$a \to a, R$ $b \to b, R$} (s1);
            
            \draw[->] (s0) -- node[below, rotate=-35] {$b \to b, R$} (sN);
            \draw[->] (s0) -- node[above, rotate=-35] {$\# \to \#, R$} (sN);

            \draw[->] (s2) -- node[below, rotate=35] {$b \to b, R$} (sN);
            \draw[->] (s2) -- node[above, rotate=35] {$\# \to \#, R$} (sN);

            \draw[->] (s2) -- node[above, rotate=-90] {$a \to \#, L$} (sY);
        \end{tikzpicture}
    \end{figure}
    Then, its corresponding TML program is the following:
\begin{lstlisting}[language=TML]
alphabet = {"a", "b"}
module s0 {
    switch tapehead {
        if a {
            changeto blank
            move right
            goto s1
        } if b {
            changeto b
            move right
            reject
        } if blank {
            changeto blank
            move right
            reject
        }
    }
}
module s1 {
    switch tapehead {
        while a {
            changeto a
            move right
        } while b {
            changeto b
            move right
        } if blank {
            changeto blank
            move left
            goto s2
        }
    }
}
module s2 {
    switch tapehead {
        if a {
            changeto blank
            move left
            accept
        } if b {
            changeto b
            move right
            reject
        } if blank {
            changeto blank
            move right
            reject
        }
    }
}
\end{lstlisting}
\end{example}

\begin{theorem} \label{thm:TM_to_TMP}
    Let $M$ be a TM, and let $P$ be the corresponding program for $M$. Then, $M$ and $P$ execute on every valid tape $T$ in the same way. That is, 
    \begin{itemize}
        \item for every valid index $n$, if we have tape $T_n$, tapehead index $i_n$ and module $m_n$ for the TM program $P$, and we have tape $S_n$, tapehead index $j_n$ and state $q_n$ for the TM $M$, then $T_n = S_n$, $i_n = j_n$ and $m_n$ is the corresponding module for $q_n$;
        \item $M$ terminates execution on $T$ if and only if $P$ terminates execution on $T$, with the same final status (\texttt{accept} or \texttt{reject}).
    \end{itemize}
\end{theorem}
\begin{proof}
    We prove this by induction on the execution step of the tape. At the start, we have the same tape $T$ for both $M$ and $P$, with tapehead index $0$. Moreover, the first module in $P$ corresponds to the initial state $q_0$. So, the result is true if $n = 0$.
    
    Now, assume that the result is true for some integer $n$, where the TM state $q_n$ is not \texttt{accept} or \texttt{reject}. In that case, $T_n = S_n$, $i_n = j_n$ and $m_n$ is the corresponding module for $q_n$. Let $\sigma_n$ be the letter at index $i_n = j_n$ on the tape $T_n = S_n$. Denote $q(q_n, \sigma_n) = (q_{n+1}, \sigma_{n+1}, \texttt{dir})$. In that case,
    \[T_{n+1}(x) = \begin{cases}
        T_n(x) & x \neq i_n \\
        \sigma_{n+1} & \text{otherwise},
    \end{cases} \qquad i_{n+1} = \begin{cases}
        i_n - 1 & \texttt{dir} = \texttt{left} \\
        i_n + 1 & \texttt{dir} = \texttt{right},
    \end{cases}\]
    and the next state is $q_{n+1}$. 
    
    We know that the module $m_n$ in TM program $P$ corresponds to the state $q_n$, so it has a \texttt{changeto} $\sigma_{n+1}$ command for the case $\sigma_n$. In the case, the next tape for $P$ is:
    \[S_{n+1}(x) = \begin{cases}
        S_n(x) & x \neq i_n \\
        \sigma_{n+1} & \text{otherwise}.
    \end{cases}\]
    So, $T_{n+1} = S_{n+1}$. 
    
    Similarly, the case also contains a \texttt{move dir} command. This implies that the next tapehead index for $P$ is:
    \[j_{n+1} = \begin{cases}
        j_n - 1 & \texttt{dir} = \texttt{left} \\
        j_n + 1 & \texttt{dir} = \texttt{right}.
    \end{cases}\]
    Hence, $i_{n+1} = j_{n+1}$. 

    Next, we consider the value of $q_{n+1}$:
    \begin{itemize}
        \item If $q_{n+1} = q_n$, then the case block is a \textit{while} block, and vice versa. So, the next module to be executed is $m_n$. In that case, $m_{n+1}$ still corresponds to $q_{n+1}$.
        \item Otherwise, we have an \textit{if} block. 
        \begin{itemize}
            \item In particular, if $q_{n+1}$ is the \texttt{accept} state, then the case for $\sigma_n$ contains the \textit{flow} command \texttt{accept}, and vice versa. In that case, execution terminates with the same final status of \texttt{accept}. The same is true for \texttt{reject}. 
            \item Otherwise, the module contains the command \texttt{goto} $m_{n+1}$, where $m_{n+1}$ is the corresponding module for $q_{n+1}$.
        \end{itemize}
    \end{itemize}
    Therefore, if the result holds for $n$, it holds for $n+1$. So, the result follows from induction.
\end{proof}

\begin{definition}
    Let $P$ be a complete TM program, and let $\Sigma$ be its alphabet. For each module $m$ in $P$, we define the \emph{corresponding state for $m$}, $q$ as follows- for each letter $\sigma$ in $\Sigma^+$, we define $\delta(q, \sigma) = (q', \sigma', \texttt{dir})$, where:
    \begin{itemize}
        \item the value $\sigma'$ is the letter given in the \textit{changeto} command within $m$;
        \item the value \texttt{dir} is the direction given in the \textit{move} command within $m$;
        \item if the \textit{flow} command in $m$ is \texttt{accept}, then $q'$ is the \texttt{accept} state; if it is \texttt{reject}, then $q'$ is the \texttt{reject} state; otherwise, $q'$ is the state corresponding to the module given in the \textit{goto} command within $m$.
    \end{itemize}
    Then, the TM with all the states $q$, alphabet $\Sigma$, the transition function $\delta$ and initial state $q_0$ corresponding to the first module in $P$ is called the \emph{corresponding TM for $P$}.
\end{definition}

\begin{example}
    Consider the following complete TM program:
\begin{lstlisting}[language=TML]
alphabet = {"a", "b"}
module moveToEnd {
    switch tapehead {
        while a {
            changeto a
            move right
        } while b {
            changeto b
            move right
        } if blank {
            changeto blank
            move left
            goto checkAFirst
        }
    }
}
module checkAFirst {
    switch tapehead {
        if a {
            changeto blank
            move left
            goto checkASecond
        } if b, blank {
            changeto blank
            move left
            reject
        }
    }
}
module checkASecond {
    switch tapehead {
        if a {
            changeto blank
            move left
            accept
        } if b, blank {
            changeto blank
            move left
            reject
        }
    }
}
\end{lstlisting}
Then, its corresponding TM is the following:
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s0) at (-0.5, 0) {$s_0$};
        \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s1) at (2, 0) {$s_1$};
        \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (s2) at (4, 1) {$s_2$};
        \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (sY) at (6, 1) {$s_Y$};
        \node[circle, draw=black, fill=white, inner sep=0pt, minimum size=15pt] (sN) at (6, -1) {$s_N$};
        
        \draw[->] (-1.5, 0) -- (s0);
        \draw[->] (s0) edge[loop above] node {$a \to a, R$} (s0);
        \draw[->] (s0) edge[loop below] node {$a \to a, R$} (s0);
        \draw[->] (s0) -- node[above] {$\# \to \#, L$} (s1);

        \draw[->] (s1) -- node[above, rotate=25] {$a \to a, L$} (s2);
        \draw[->] (s1) -- node[below, rotate=-15, pos=0.4] {$\# \to \#, L$} (sN);
        \draw[->] (s1) -- node[above, rotate=-15, pos=0.4] {$b \to \#, L$} (sN);

        \draw[->] (s2) -- node[above] {$\# \to \#, L$} (sY);

        \draw[->] (s2) -- node[above, rotate=-45] {$b \to \#, L$} (sN);
        \draw[->] (s2) -- node[below, rotate=-45] {$\# \to \#, L$} (sN);
    \end{tikzpicture}
    \caption{The TM corresponding to the program above. The state $s_0$ corresponds to the module \texttt{moveToEnd}; the state $s_1$ corresponds to the module \texttt{checkAFirst}; and the state $s_2$ corresponds to the module \texttt{checkASecond}.}
\end{figure}
\end{example}

\begin{theorem} \label{thm:TMP_to_TM}
    Let $P$ be a complete TM program, and let $M$ be the corresponding TM for $P$.  Then, $P$ and $M$ execute on every valid tape $T$ in the same way. That is,
    \begin{itemize}
        \item for every valid index $n$, if we have tape $T_n$, tapehead index $i_n$ and module $m_n$ for TM program $P$, and we have tape $S_n$, tapehead index $j_n$ and state $q_n$ for the TM $M$, then $T_n = S_n$, $i_n = j_n$ and $q_n$ is the corresponding state for $m_n$;
        \item $P$ terminates execution on $T$ if and only if $M$ terminates execution on $T$, with the same final status (\texttt{accept} or \texttt{reject}).
    \end{itemize}
\end{theorem}
\begin{proof}
    We prove this as well by induction on the execution step of the tape. At the start, we have the same tape $T$ for both $P$ and $M$, with tapehead index $0$. Moreover, the initial state $q_0$ in $M$ corresponds to the first module in $P$. So, the result is true if $n = 0$. 
    
    Now, assume that the result is true for some integer $n$, which is not the terminating step in execution. In that case, $S_n = T_n$, $j_n = i_n$ and $q_n$ is the corresponding state for $m_n$. Let $\sigma_n$ be the letter at index $j_n = i_n$ on the tape $S_n = T_n$. 
    
    We now consider the block $m_n$:
    \begin{itemize}
        \item If the block in $m_n$ corresponding to $\sigma_n$ is a \textit{while} block, then we know that its body is partially complete, and so is composed of the following commands:
        \begin{itemize}
            \item \texttt{changeto} $\sigma_{n+1}$
            \item \texttt{move dir}
        \end{itemize}
        So, we have $\delta(q_n, \sigma_n) = (q_n, \sigma_{n+1}, \texttt{dir})$. Using the same argument as in \textbf{\ref{thm:TM_to_TMP}}, we find that $T_{n+1} = S_{n+1}$ and $i_{n+1} = j_{n+1}$. Also, $q_{n+1} = q_n$ is the corresponding state for $m_{n+1} = m_n$. 
        
        \item Otherwise, we have an \textit{if} command. In this case, the case body is complete, and so composed of the following commands:
        \begin{itemize}
            \item \texttt{changeto} $\sigma_{n+1}$
            \item \texttt{move dir}
            \item \texttt{accept}, \texttt{reject} or \texttt{goto} $m_{n+1}$.
        \end{itemize}
        So, we have $\delta(q_n, \sigma_n) = (q_{n+1}, \sigma_{n+1}, \texttt{dir})$, where $q_{n+1}$ is the corresponding state to the \textit{flow} command present. Here too, we have $T_{n+1} = S_{n+1}$ and $i_{n+1} = j_{n+1}$ by construction. Now, we consider the flow command:
        \begin{itemize}
            \item If we have an \texttt{accept} command in the body, then $q_{n+1}$ is the accepting state, and vice versa. So, we terminate execution with the final status of \texttt{accept}. The same is true for \texttt{reject}. 
            \item Otherwise, the state $q_{n+1}$ is the corresponding state to the module $m_{n+1}$. In all cases, there is a correspondence between the state for $m_{n+1}$ and $q_{n+1}$.
        \end{itemize}
    \end{itemize}
    So, the result follows from induction.
\end{proof}

\subsection{Valid to complete programs}
In this section, we will show that for every valid program, there is a corresponding complete program. We will first define how to `complete' a valid program, and then show that the completion executes on a tape in the same way as a valid program.
\begin{definition}
    Let $P$ be a TM program. We define the TM program $P_1$ to be the \emph{first completion of $P$} as follows:
    \begin{itemize}
        \item the alphabet of $P_1$ is the same as the alphabet of $P$;
        \item for every block $b$ in every module $m$ of $P$, $P_1$ has a module with body the block $b$. If the block is not the final block in $m$, it has an additional flow command to the next block in the module. The order of the modules is the same as the order of the original blocks.
    \end{itemize}
    We define the TM program $P_2$ to be the \emph{second completion of $P$} as follows:
    \begin{itemize}
        \item the alphabet of $P_2$ is the same as the alphabet of $P$;
        \item for every module $m$ of $P$ with a \textit{basic} block, replace it with a \textit{switch} block where every case is an \textit{if} command with body the original basic block.
    \end{itemize}
    Finally, we define the TM program $P^+$ to be the \emph{(third) completion of $P$} as follows:
    \begin{itemize}
        \item the alphabet of $P^+$ is the same as the alphabet of $P$;
        \item for every non-complete module $m$ of $P$, replace it with a complete block by adding the default commands:
        \begin{itemize}
            \item if the \textit{changeto} command is missing, add the \textit{changeto} command corresponding to the case value;
            \item if the \textit{move} command is missing, add the command \texttt{move left};
            \item if the \textit{flow} command is missing, add the command \texttt{reject}.
        \end{itemize}
    \end{itemize}
\end{definition}

\begin{remark}
    For any TM program $P$, its completion $P^+$ is complete by construction.
\end{remark}

\begin{remark}
    Let $P$ be a TM program. For every block $b$ in $P$, there is a complete module $m$ in the completion program $P^+$. We say that $m$ is the \emph{corresponding complete module} of $b$.
\end{remark}

\begin{example}
    Consider the following TM program:
\begin{lstlisting}[language=TML]
alphabet = {"a", "b"}
module simpleProgram {
    changeto b
    move left
    move right
    accept
}
\end{lstlisting}
\noindent Them, its first completion is the following program:
\begin{lstlisting}[language=TML]
alphabet = {"a", "b"}
module simple1 {
    changeto b
    move left
    goto simple2
}
module simple2 {
    move right
    accept
}
\end{lstlisting}
\noindent The second completion is the following program:
\begin{lstlisting}[language=TML]
alphabet = {"a", "b"}
module simple1 {
    switch tapehead {
        if a, b, blank {
            changeto b
            move left
            goto simple2
        }
    }
}
module simple2 {
    switch tapehead {
        if a, b, blank {
            move right
            accept
        }
    }
}
\end{lstlisting}
\noindent Finally, the completion of $P$ is the following:
\begin{lstlisting}[language=TML]
alphabet = {"a", "b"}
module simple1 {
    switch tapehead {
        if a {
            changeto b
            move left
            goto simple2
        } if b {
            changeto b
            move left
            goto simple2
        } if blank {
            changeto b
            move left
            goto simple2
        }
    }
    }
    module simple2 {
    switch tapehead {
        if a {
            changeto a
            move right
            accept
        } if b {
            changeto b
            move right
            accept
        } if blank {
            move right
            accept
        }
    }
}
\end{lstlisting}
\end{example}

\begin{theorem}
    Let $P$ be a valid TM program. Then, $P$ and its completion $P^+$ execute on every valid tape $T$ in the same way. That is,
    \begin{itemize}
        \item for every valid index $n$, if we have tape $T_n$, tapehead index $i_n$ and module $m_n$ with executing block $b_n$ for the TM program $P$, and we have tape $S_n$, tapehead index $j_n$ and module $t_n$, then $T_n = S_n$, $i_n = j_n$, and $t_n$ is the corresponding complete module block of $b_n$;
        \item $P$ terminates execution on $T$ if and only if $P^+$ terminates execution on $T$, with the same final status (\texttt{accept} or \texttt{reject}).
    \end{itemize}
\end{theorem}
\begin{proof}
    We prove this by induction. At the start, we have the same tape $T$ for both $P$ and $P^+$, with tapehead index 0. Moreover, the corresponding (complete) module of the first block in the first module of $P$ is the first module of $P$. So, the result is true if $n = 0$. 
    
    Now, assume that the result is true for some integer $n$, where the block $b_n$ in the TM program $P$ does not end with a terminating \textit{flow} command. Let $\sigma_n$ be the letter at index $i_n = j_n$ on the tape $S_n = T_n$.
    
    If the \textit{changeto} command is missing in $b_n$ for $\sigma_n$, then the next tape $T_{n+1} = T_n$. In the complete module $m_n$, the case for $\sigma_n$ will have \texttt{changeto} $\sigma_n$. So, the next tape is given by:
    \[S_{n+1}(x) = \begin{cases}
        S_n(x) & x \neq j \\
        \sigma_n & \text{otherwise}
    \end{cases}.\]
    Therefore, we have $S_{n+1} = S_n$ as well. So, $T_{n+1} = S_{n+1}$. Otherwise, we have the same \textit{changeto} command, in which case $T_{n+1} = S_{n+1}$ as well.

    If the \textit{move} command is missing in $b_n$ for $\sigma_n$, then the next tapehead index $i_{n+1} = i_n - 1$. In the complete module $m_n$, the case for $\sigma_n$ will have \texttt{move left}, so we also have $j_{n+1} = j_n - 1$. So, we have $i_{n+1} = j_{n+1}$. Otherwise, we have the same \textit{move} command, meaning that $i_{n+1} = j_{n+1}$.

    If the block $b_n$ is a \textit{switch} block with a \textit{while} case for $\sigma_n$, then this is still true in the module $m_n$. So, the next block to be executed in $P$ is $b_n$, and the next module to be executed in $P^+$ is $m_n$. In that case, the corresponding module of the block $b_{n+1} = b_n$ is still $m_{n+1} = m_n$.
    
    Instead, if the block $b_n$ has no \textit{flow} command for $\sigma_n$, and is not the last block, then the next block to execute is the block just below $b_n$, referred as $b_{n+1}$. By the definition of $P^+$, we find that the case block in the module $m_n$ has a \textit{goto} command, going to the module $m_{n+1}$ which corresponds to the block $b_{n+1}$. 
    
    Now, if the \textit{flow} command is missing for $\sigma_n$ and this is the last block, then execution is terminated with the status \texttt{reject} for the program $P$. In that case, the case for $\sigma_n$ in the module $m_n$ has the \texttt{reject} command present, so the same happens for $P^+$ as well. 
    
    Otherwise, both $P$ and $P^+$ have the same flow command, meaning that there is either correspondence between the next module to be executed, or both the program terminate with the same status. In that case, $P$ and $P^+$ execute on $T$ the same way by induction.
\end{proof}

\end{document}
