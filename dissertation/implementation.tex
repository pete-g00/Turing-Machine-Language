\chapter{Implementation}
\section{Language}

The TML has been implemented in a way that closely resembles the operations in a TM. In particular, 
\begin{itemize}
    \item it expects an alphabet like a TM;
    \item it makes use of \texttt{move} commands to move the tapehead value in some direction;
    \item it makes use of \texttt{changeto} commands to change the tapehead value to some letter in the alphabet.
\end{itemize}
Instead of states, the TML has modules. A module can be thought of as a state, although a module is more expressible than a state. We want modules to also be thought of as functions or methods within a traditional PL. To allow for flow of code to go from one module to another, we can make use of \texttt{goto} commands. We can go to the accept and reject states using the keywords \texttt{accept} and \texttt{reject} respectively.

The following program illustrates a simple program in TML with all the basic operations:
\begin{lstlisting}[language=TML]
alphabet = {a, b}
module first {
    changeto blank
    move right
    goto second
}
module second {
    move left
    accept
}
\end{lstlisting}
A program is run starting from the first module. In this case, we first start at module \texttt{first}. Here, the first tape value is removed, the tape pointer moves to the right and we go to module \texttt{b} and continue execution. Note that we allow recursion- line 5 can be replaced with \texttt{goto first}.

To represent the transition function in TMs, the language makes use of pattern-matching. Since this should resemble a traditional PL, this is done using \texttt{if} cases. This is shown in the example below.
\begin{lstlisting}[language=TML]
if a {
    move right
    accept
} if b, blank {
    changeto blank
}
\end{lstlisting}
With these constructs, we have constructed a language that is equivalent to TMs. 

Although the language is already equivalent to TMs, we will add some more flexibility in the language since all programs that can be written with these constructs are quite similar to TMs. To mitigate this, we add nesting within \texttt{if} statements. That way, we can write programs that are more comparable to normal programs written in other languages, such as the program below.
\lstinputlisting[language=TML]{code/isDiv2Rec.txt}
In this program, we have nested an \texttt{if} block within an \texttt{if} block in lines 11-15.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \node[state, accepting] (q0) at (0, 0) {$q_0$};
        \node[state] (q1) at (2.5, -1) {$q_1$};
        \node[state, fill=green, opacity=0.6] (A) at (2.5, 1) {$A$};
        \node[state, fill=red, opacity=0.6] (R) at (5, -1) {$R$};

        \draw[->] (q0) -- node[above, rotate=20] {$0|\#, R$} (A);
        \draw[->] (q0) -- node[below, rotate=-20] {$1, R$} (q1);
        \draw[->] (q1) edge[loop below] node {$0|1, R$} (q1);
        \draw[->] (q1) -- node[below] {$\#, L$} (R);
    \end{tikzpicture}
    \caption{A TM with a self-loop at the state $q_1$}
    \label{fig:self-loop-TM}
\end{figure}
Although nesting has made the language more like a typical PL, there is still one issue- a self-loop in a non-starting state. To see this, we consider the TM at Figure \ref{fig:self-loop-TM}. Currently, the following is the only way to represent this TM as a TML program:
\begin{lstlisting}[language=TML]
alphabet = {0, 1}
module q0 {
    if 0, blank {
        move right
        accept
    } if 1 {
        move right
        goto q1
    }
}
module q1 {
    if 0, 1 {
        move right
        goto q1
    } if blank {
        move left
        reject
    }
}
\end{lstlisting}
What we have is a \emph{complete program}- there is a one-to-one correspondence between a module and a state. It is not possible to combine the 2 modules- recursion would convert the self-loop of $q_1$ to a transition from $q_1$ to $q_0$. It is always possible to represent a TM as a complete program, but this representation is very close to a TM. We want there to be another way to represent this program that resembles a PL better.

To allow for self-loops using nesting, we introduce a new construct- a \texttt{while} case. This is similar to an \texttt{if} case, but after the block is executed, we stay at the same block (which does not necessarily mean that the same case is run). This is precisely a self-loop. We can now convert the TM above to a single module:
\begin{lstlisting}[language=TML]
alphabet = {0, 1}
module program {
    if 0, blank {
        move right
        accept
    } if 1 {
        move right
        while 0, 1 {
            move right
        } if blank {
            move left
            reject
        }
    }
}
\end{lstlisting}

The formal syntax of the language is given in the appendix, along with a proof of equivalence between TMs and TML programs in terms of code execution. The proof of equivalence is composed of several proofs, which involve:
\begin{itemize}
    \item converting a TM into a complete TML program;
    \item converting a valid TML program into a complete TML program; and
    \item converting a complete TML program into a TM program.
\end{itemize}

\section{Parser}
TODO
% TODO: Parser was written using TypeScript instead of using ANTLR for web use
% TODO: Parser makes use of the visitor design pattern, specify in particular what each one uses
% TODO: A syntax tree is given
% TODO: Some validation rules are given
% TODO: TM representation is given
% TODO: TM converter and TML converter are explained
% TODO: Describe some non-trivial stuff to write, e.g. breaking from the visitor design pattern to allow for non-useless code

\section{Product}
TODO
% TODO: Website was written in react for its rich set of frameworks
% TODO: The FSM is created using graphviz. Constructs an aesthetically pleasing FSM given the nodes. Uses DOT notation. Initial attempt was to do it myself and create an algorithm that works, but decided instead to do this. This does still have limitations which are discussed in future work
% TODO: The editor comes from monaco framework
% TODO: d3 framework used to show tape transitions (move, change of tape value)
