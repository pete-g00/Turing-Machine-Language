\chapter{Conclusion}

% Summarise the whole project for a lazy reader who didn't read the rest (e.g. a prize-awarding committee).
% -> Summarise briefly and fairly.
% ->  You should be addressing the general problem you introduced in the Introduction.        
% -> Include summary of concrete results (``the new compiler ran 2x faster'')

\section{Summary}
TODO

% Turing Machines are a model of computation that is typically taught to computing students after some years of coding experience. They are normally taught the concept using finite state machines. This is quite different to how they have been taught programming previously, and they might find it easier to learn the concept in a way that resembles coding closely. This project presents a language to represent TMs.

% Summarise what you did; answer the general questions you asked in the introduction. What did you achieve? Briefly describe what was built and summarise the evaluation results.

\section{Reflection}
TODO
% Discuss what went well and what didn't and how you would do things differently if you did this project again.

\section{Future Work}

There are many additions that can be made to the language and the product in future. Some of these were discovered during production, and some as part of the user evaluation.

\subsection{Language}
Although the language is equivalent to TMs, and has a few features that resemble a traditional PL, it is still quite low-level. There are many common paradigms that can be added to the language. These include:
\begin{enumerate}
    \item the ability to traverse to the end (or the start) of the tape string in one command, e.g. \texttt{move end}; 
    \item an \textit{else} block (an \textit{if} block for the remaining letters); and
    \item the ability for modules to be parameterised with respect to letters.
\end{enumerate}
We illustrate these issues with the following program:
\lstinputlisting[language=TML]{code/fut_work_tml.txt}

The first feature is a very common feature found in program- many programs involving some check on the final character. For example, in the program above, we are traversing to the end twice- at lines 5-9 and 17-21. Hence, I believe this would be a highly beneficial feature to add.

The second point is also somewhat common and was suggested in the survey. At many points during execution, we want to do something for a single letter and something different for the other letters. For instance, in the example above, at lines 10-13, we want the program to accept the string if and only if the letter is a \texttt{b}. If the alphabet was longer, this would be quite inefficient. Also, another point that was raised during the survey was that the language only makes use of pattern-matching, and could be more flexible. So, this would be a great feature to extend the language. 

The final feature is quite interesting. There are many programs where the modules are very similar and only differ in some letters. For example, the program above has 2 essentially mirrored blocks at lines 4-16 and 16-28. In particular, the only difference in these lines of code is at lines 10/12 and 22/24, where the letters \texttt{a} and \texttt{b} are the other way round. Hence, I believe that adding this feature would make many programs in TML shorter and less repetitive! Moreover, this would make the language further resemble a traditional PL.

% Finally, there is an open question about the language- the ability to convert a TM into a `good' TML program. Currently, the proof of equivalence makes use of an algorithm to convert a valid TML program to a complete TML program, but not vice versa. Complete TML programs can be thought of as another representation for TMs, and so add no further benefit to the language. It is the ability to nest blocks within \textit{if} commands that really makes the language rich and different to TMs. For this reason, I believe it would be a good idea to devise an algorithm to convert a TM (or a complete TML program) to a nested TML program.

% One way to do so would be to achieve maximum nesting by replacing \texttt{goto} commands with the actual module, however this is not optimal- there would be a lot of duplicate code present. Instead, it might be a good idea to only replace modules that are only called once, and to keep modules that are called multiple times separate. The main benefit of this is that complete TML programs are essentially another representation of TMs and quite distant from TML programs. I believe valid, non-complete

 \subsection{Product}
There are many possible improvements to the website. These are some of the features that can be added:
\begin{itemize}
    \item support for direct execution of a TM;
    \item a play button on the tape section to execute long programs on long tapes without pressing the step button many times;
    \item the ability to collapse the panels; and
    \item the ability to customise the number of tape entries shown so that it is easier to follow code execution on long strings.
\end{itemize}
All of these are great features that could be added to the website and would make it easier to use!

We could also improve the website by making the TM panel more responsive. The FSM is currently being produced using the graphviz framework. The resulting SVG has hard-coded dimensions. This makes it hard to make the panel responsive. It is not completely possible to make the graph fixed; only the maximum size of the SVG can be specified. Moreover, the constraints are not taken into consideration when the API produces the FSM. This means that for complex TM, the states are quite small and hard to see. This makes it hard to follow the execution process. To fix this, we could add one of the following features:
\begin{itemize}
    \item the FSM might produced as it currently is, but the user can zoom in and drag the FSM panel; or
    \item the FSM might be produced so that the states always have the same size, but the user can scroll the panel. 
\end{itemize}
